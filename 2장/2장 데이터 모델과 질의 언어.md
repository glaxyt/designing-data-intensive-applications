## 데이터 모델의 중요성

데이터 모델은 아마도 소프트웨어 개발에서 제일 중요한 부분이다.
데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 **문제를 어떻게 생각해야 하는지에 대해서도** 지대한 영향을 미치기 때문이다.

개발자는 데이터를 추상화하여 하나의 계층 위에 또 하나의 데이터 계층을 만든다. 데이터를 추상화하여 데이터 계층을 쌓아나간다. 각 계층의 데이터 모델은 하위 계층의 복잡성을 숨긴다.

어플리케이션이 어떤 데이터를 다루느냐에 따라 어떤 데이터 모델을 선택할지 결정된다. 데이터 모델은 소프트웨어가 할 수 있는 일과 없는 일에 영향을 주므로 어플리케이션에 적합한 모델을 찾는 것이 중요하다.

## 관계형 모델과 문서 모델 (**Relational Model Versus Document Model)**

- 오늘날 가장 잘 알려진 데이터 모델은 관계형 모델을 기반으로 한 SQL이다.
- 관계형 데이터베이스의 근원은 비즈니스 데이터 처리에 있다. (1960 ~ 1970)
  - **트랜잭션 처리** : 영업이나 은행 거래, 항공 예약, 창고에 재고 보관
  - **일괄 처리** : 고객 송장 작성, 급여 지불, 보고
- 관계형 모델의 목표는 정리된 인터페이스 뒤로 구현 세부 사항을 숨기는 것이다.
- 1970 ~ 1980에는 네트워크 모델과 계층 모델이 주요 대안이었지만, 관계형 모델이 우위를 차지함
- 오늘날 웹에서 볼 수 있는 대부분의 서비스도 관계형 데이터베이스를 통해 제공된다.

## **NoSQL의 탄생 (The Birth of NoSQL)**

- NoSQL 데이터베이스를 채택한 다양한 이유
  1. 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
  2. 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
  3. 관계형 모델에서 지원하지 않는 특수 질의 동작
  4. 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람
- **다중 저장소 지속성 (polyglot persistence)** : 관계형 데이터베이스 + 비관계형 데이터스토어

## **객체 관계형 불일치 (The Object-Relational Mismatch)**

객체 관계형 불일치가 발생하는 이유

- 대부분의 애플리케이션은 객체지향 프로그래밍 언어로 개발
- 데이터가 저장되기 위해 객체지향 어플리케이션 코드가 데이터 베이스 모델 객체로 전환 필요
  - 관계형 테이블에 저장하기 위해선 애플리케이션 코드와 데이터 베이스 모델 객체 사이에서 거추장스러운 전환 계층 발생
  - 이런 모델 사이의 분리를 **임피던스 불일치 (impedance mismatch)**라 함

![image](https://github.com/user-attachments/assets/2c0b4fb7-1de7-409a-97e5-5c2018590532)

위 문서를 나타내는데 사용할 수 있는 방법은 아래와 같이 크게 3가지가 존재한다.

1. 전통적인 SQL 모델에서 가장 일반적인 정규화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 넣고 외래키로 관계를 설정
2. SQL 에서 구조화된 데이터타입과 XML 데이터에 대한 지원을 추가하였다.
   - 따라서 단일 튜플에 다중 값을 저장할 수 있고 문서 내 질의와 색인이 가능해졌다.
3. 직업, 학력, 연락처 정보를 JSON이나 XML 문서로 부호화해 데이터베이스의 텍스트 칼럼에 저장한 다음 애플리케이션이 구조와 내용을 해석하게 하는 방식이다. 하지만 이 방식을 쓰면 일반적으로 부호화된 칼럼의 값을 질의하는데 데이터베이스를 사용할 수 없다.

## **다대일과 다대다의 관계**

![image](https://github.com/user-attachments/assets/0e66a20a-ca4e-4a7d-824d-7718941de827)

(위 이력서 예제에서 region_id와 inderstry_id를 평문 대신 ID로 저장)

의미 있는 정보를 한곳에만 저장하고 이를 ID로 참조 join을 통해 참조

### 장점

- 프로필 간 일관된 스타일과 철자 가능
- 모호함 회피와 갱신의 편의성
  - 현실과 독립된 데이터를 칼럼으로 설정함으로써 현실이 데이터베이스에 줄 수 있는 영향을 최소화
- 현지화 사이트에서는 현지에 맞는 언어로 표시하기 편함
- 중복된 데이터의 쓰기 오버헤드와 불일치 위험을 줄일 수 있음

이전에도 개발자 관련 책에서 현실과 데이터 모델링 간의 분리가 중요하다고 읽었다.

이 중에서 중요한 부분이 ID와 같은 인공키를 활용함으로써 현실의 영향을 최소화하는 것이 있다.

- ex) 주민등록번호가 보안 문제로 인한 중요성 문제로 만들어진 국가 정책이 영향을 줄 수 있다.
  - 이렇게 되면 주민등록번호를 PK로 사용하는 회사는 데이터 모델링의 변경이 불가피하다.

## 중복된 데이터를 정규화하려면

### 문서 모델에서의 Many-to-one

- One-to-many 트리 구조를 위해 Join연산이 필요치 않음
  - 보통 join연산에 대한 지원이 약함
- Join이 필요하면 보통 애플리케이션 코드에서 Join을 흉내내야 한다
- 애플리케이션에 기능이 추가되면서 Join이 필요없던 데이터간에도 Join이 필요한 경우가 생긴다.
  - ex) 추천인의 프로필 사진 변경

## 문서 지향 데이터베이스의 역사적 반복

### 1. 과거의 데이터 저장 방식

- 초기의 데이터 저장은 파일 시스템 기반으로, 각 애플리케이션이 자체적인 파일 형식을 사용하여 데이터를 저장했습니다.
- 이러한 방식은 데이터 공유와 통합에 어려움을 겪었고, 데이터 중복과 일관성 문제를 야기했습니다.

### 2. 관계형 데이터베이스의 등장

- 1970년대에 관계형 데이터베이스(RDBMS)가 등장하면서 데이터 저장과 관리에 혁신을 가져왔습니다.
- 정형화된 스키마와 SQL을 통한 질의는 데이터의 일관성과 통합을 가능하게 했습니다.

### 3. 문서 지향 데이터베이스의 부상

- 최근에는 JSON과 같은 유연한 데이터 형식을 사용하는 문서 지향 데이터베이스가 인기를 끌고 있습니다.
- 이러한 시스템은 스키마가 유연하거나 없는 것처럼 보이지만, 실제로는 암묵적인 스키마가 존재합니다.

### 4. 역사적 반복의 우려

- 문서 지향 데이터베이스의 유연성은 초기 파일 시스템 기반 저장 방식과 유사한 문제를 다시 야기할 수 있습니다.
- 스키마가 명확하지 않으면 데이터 일관성과 통합에 어려움을 겪을 수 있으며, 이는 과거의 문제를 반복하는 것입니다.

## 네트워크 모델

- 네트워크 모델은 코다실이라 불리는 위원회에서 표준화
- 코다실 모델은 계층 모델을 일반화
- 계층 모델의 트리 구조에서 모든 레코드는 정확하게 하나의 부모가 있음
  - 다중 부모가 있을 수 있음
  - 코다실 모델은 다대일과 다대다 관계를 모델링할 수 있음
- 그러나 레코드 간의 연결이 외래키가 아닌 포인터에 가까운 접근 경로를 통해서 접근한다. 이를 접근 경로라고 함
- 여기서 발생하는 문제점은 레코드가 다중 부모를 가지고 있을 경우, 애플리케이션 코드는 다양한 관계를 모두 추적해야 함
- 이로 인해 데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못한 문제 발생

## 관계형 모델

- 관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것
- 관계는 단순한 튜플(행)의 컬렉션이 전부
- 이렇기에 네트워크 모델처럼 복잡한 접근경로가 없음
- 테이블의 일부 혹은 모든 행을 선택해서 읽을 수 있고, 특정 컬럼을 조건으로 일치하는 행을 읽을 수 있음
- 관계형 데이터베이스의 질의 최적화는 것은 사실상 접근 경로를 선택하는 것인데 이를 옵티마이저가 자동으로 최적화해줌

## 문서형 데이터베이스와의 비교

- 문서 데이터베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장하는 부분에서는 계층 모델을 사용함
- 하지만 다대일, 다대다 관계를 표현할 때는 관계형 데이터베이스와 크게 다를 바가 없음

## **관계형 모델 vs 문서형 모델**

- `문서 데이터 모델`을 선호하는 이유로, 스키마 유연성, 지역성에 기인한 더 나은 성능 때문. 또한 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 가깝기 때문
- 관계형 모델로 표현하려 한다면 정규화 같은 데이터를 **찢는 관계형 기법** 때문에 불필요한 복잡성이 증가함
- 또한 중첩 항목을 접근 경로를 통해서 접근해야하기에 깊은 중첩 데이터 구조가 구성되면 문제가 발생할 수 있음.
- `관계형 모델`을 선호하는 이유는, 조인, 다대일, 다대다 관계를 더 잘 지원
  - 문서형 모델에서 다대다, 다대일 관계를 표현하기 위해서 비정규화, 애플리케이션 코드 내에서 조인 로직을 작성해야하는데 이는 DB에서 특화된 조인 로직보다 성능이 떨어짐
  - 조인의 기능을 애플케이션 코드에서 담당하기에 복잡도가 증가

## 질의를 위한 데이터 지역성

- 웹 페이지 상에 문서를 보여주는 동작처럼 애플리케이션이 자주 전체 문서에 접근해야 할 때 **저장소 지역성**을 활용하면 성능 이점이 있음
- 데이터가 찢기 관계형 기법처럼 정규화가 되어있다면, 다중 색인 검색을 위한 많은 디스크 검색이 수행됨
- 구글의 스패너 데이터베이스, 오라클의 다중 테이블 색인 클러스터 테이블 기능과 같이 관계형 데이터 모델에서도 지역성 특성을 제공받을 수 있음

###

## **관계형 데이터베이스와 오늘날의 문서 데이터베이스**

## **문서 데이터베이스와 관계형 데이터베이스의 통합**

### 관계형 데이터베이스의 문서 지원

- XML: MySQL제외한 대부분의 RDBMS
- JSON: PostgresSQL(9.3+), MySQL(5.7+), IBM DB2(10.5+)
- 결과적으로 많은 관계형 데이터베이스가 JSON 문서나 XML을 지원함에 따라 문서형 데이터베이스를 닮아가고 있음

### 문서 데이터베이스의 조인 지원

- DBMS Join
  - RethinkDB
- Client(driver) Join
  - MongoDB driver : 자동으로 데이터베이스 참조 확인
- 문서형 데이터베이스에서도 조인과 참조 기능을 추가하고 있음에 따라 관계형 데이터베이스를 닮아가고 있음

- 문서 데이터베이스와 관계형 데이터베이스는 각 데이터 모델이 부족한 부분을 보완해 나가고 있음

## 데이터를 위한 질의 언어

### 1. 질의 언어의 유형

### 명령형 질의 언어 (Imperative Query Language)

- **정의**: 컴퓨터에게 특정 순서로 연산을 수행하도록 명시적으로 지시하는 방식입니다.
- **특징**
  - 결과를 얻기 위한 알고리즘을 개발자가 직접 지정해야 합니다.
  - 예를 들어, 특정 조건을 만족하는 데이터를 찾기 위해 루프와 조건문을 사용하여 직접 구현합니다.
  - 병렬 처리에 적합하지 않으며, 코드의 유지보수가 어렵습니다.
- **예시**
  - JavaScript를 사용하여 특정 조건을 만족하는 데이터를 필터링하는 코드.

### 선언형 질의 언어 (Declarative Query Language)

- **정의**: 원하는 결과가 무엇인지 선언적으로 표현하며, 어떻게 결과를 얻을지는 시스템이 결정합니다.
- **특징**
  - 개발자는 결과의 조건과 필요한 변환(정렬, 그룹화, 집계 등)만 지정합니다.
  - 쿼리 최적화기가 실행 계획을 수립하여 효율적으로 처리합니다.
  - 병렬 처리에 유리하며, 코드가 간결하고 유지보수가 용이합니다.
- **예시**
  - SQL: `SELECT * FROM animals WHERE family = 'Sharks';`

### 2. 맵리듀스(MapReduce) 질의

- **정의**: 대용량 데이터를 분산 환경에서 처리하기 위한 프로그래밍 모델입니다.
- **특징**:
  - Map 단계에서 데이터를 필터링하고, Reduce 단계에서 결과를 집계합니다.
  - 일부 NoSQL 데이터베이스(MongoDB, CouchDB 등)에서 지원합니다.
  - 선언형과 명령형의 중간 형태로, 개발자가 Map과 Reduce 함수를 정의해야 합니다.
- **예시**:
  - MongoDB의 MapReduce 기능을 사용하여 특정 조건의 데이터를 집계하는 작업.

### 3. 웹에서의 선언형 질의

- **비유적 설명**:
  - 웹 개발에서 CSS는 선언형 방식으로 스타일을 지정하며, JavaScript의 DOM 조작은 명령형 방식입니다.
  - CSS를 사용하면 스타일 변경이 간단하고 유지보수가 용이하지만, JavaScript를 사용하면 코드가 복잡해지고 유지보수가 어려워집니다.
- **데이터베이스와의 유사성**:
  - 선언형 질의 언어(SQL 등)는 CSS와 유사하게 간결하고 효율적인 질의를 가능하게 합니다.
  - 명령형 질의 언어는 JavaScript의 DOM 조작처럼 복잡하고 유지보수가 어렵습니다.

### 4. 요약

- **명령형 질의 언어**는 개발자가 모든 절차를 명시해야 하므로 복잡하고 유지보수가 어렵습니다.
- **선언형 질의 언어**는 원하는 결과를 선언적으로 표현하여 시스템이 최적의 실행 계획을 수립하므로 효율적이고 유지보수가 용이합니다.
- **맵리듀스**는 대용량 데이터 처리를 위한 모델로, 선언형과 명령형의 중간 형태입니다.
- 웹 개발에서의 CSS와 JavaScript의 관계처럼, 데이터베이스에서도 선언형 질의 언어의 사용이 권장됩니다.
